var h=require("fs").promises,x=require("fs"),u=require("crypto"),_=require("events"),g=require("zlib"),m=require("util"),d=require("path"),y=m.promisify(g.gzip),D=m.promisify(g.gunzip),w=class{constructor(t,e=null,i={}){this.databaseDir=t,this.encryptionKey=e?Buffer.from(e):this._generateSecureKey(),this.options={encrypt:!0,compression:!0,walEnabled:!0,syncWrites:!0,maxWalSize:100*1024*1024,checkpointInterval:3e4,lockTimeout:1e4,walPaddingSize:1024,...i},this.eventEmitter=new _,this.indexes=new Map,this.locks=new Map,this.lockQueue=new Map,this.transactions=new Map,this.schemas=new Map,this.walSequence=0,this.walBuffer=[],this.isCheckpointing=!1,this.checkpointTimer=null,this.isClosed=!1,this.walSalt=null,this.walKey=null,this.walEncrypted=!1,this.initializationPromise=null,this.isInitialized=!1,this.initializationPromise=this._initializeDatabase()}async ensureInitialized(){this.isInitialized||await this.initializationPromise}async ready(){return await this.ensureInitialized(),this.isInitialized}async _initializeDatabase(){try{await h.mkdir(this.databaseDir,{recursive:!0}),await h.mkdir(d.join(this.databaseDir,"wal"),{recursive:!0}),await h.mkdir(d.join(this.databaseDir,"indexes"),{recursive:!0}),await this._initializeWALEncryption(),this.options.walEnabled&&await this._recoverFromWAL(),this.isInitialized=!0,this._startCheckpointScheduler()}catch(t){throw new Error(`Database initialization failed: ${t.message}`)}}async _initializeWALEncryption(){let t=d.join(this.databaseDir,"wal",".salt");try{let e=await h.readFile(t);this.walSalt=e}catch(e){if(e.code==="ENOENT")this.walSalt=u.randomBytes(32),this.options.encrypt&&await h.writeFile(t,this.walSalt);else throw e}if(this.options.encrypt&&this.encryptionKey&&this.options.walEnabled?(this.walKey=this._deriveWALKey(),this.walEncrypted=!0):this.walEncrypted=!1,this.options.encrypt&&this.options.walEnabled&&!this.walEncrypted)throw new Error("WAL encryption failed to initialize properly")}_generateSecureKey(){return u.randomBytes(32)}_deriveWALKey(){if(!this.walSalt)throw new Error("WAL salt not initialized");if(!this.encryptionKey)throw new Error("Encryption key not provided");if(this.encryptionKey.reduce((e,i)=>e+i,0)===0)throw new Error("Encryption key has been wiped - cannot derive WAL key");try{return u.pbkdf2Sync(this.encryptionKey,this.walSalt,1e5,32,"sha256")}catch(e){throw new Error(`WAL key derivation failed: ${e.message}`)}}_encryptData(t){if(!this.options.encrypt)return JSON.stringify(t);try{let e=JSON.stringify(t),i=u.randomBytes(16),r=u.createCipheriv("aes-256-gcm",this.encryptionKey,i),s=r.update(e,"utf8");s=Buffer.concat([s,r.final()]);let n=r.getAuthTag();if(n.length!==16)throw new Error(`Invalid authentication tag length: ${n.length}`);return i.toString("hex")+":"+n.toString("hex")+":"+s.toString("hex")}catch(e){throw new Error(`Encryption failed: ${e.message}`)}}_decryptData(t){if(!this.options.encrypt)try{return JSON.parse(t)}catch{throw new Error("Invalid unencrypted data format")}try{let e=t.split(":");if(e.length!==3)throw new Error("Invalid encrypted data format");let i=Buffer.from(e[0],"hex"),r=Buffer.from(e[1],"hex"),s=Buffer.from(e[2],"hex");if(i.length!==16)throw new Error(`Invalid IV length: expected 16, got ${i.length}`);if(r.length!==16)throw new Error(`Invalid authentication tag length: expected 16, got ${r.length}`);if(s.length===0)throw new Error("Empty ciphertext");let n=u.createDecipheriv("aes-256-gcm",this.encryptionKey,i);n.setAuthTag(r);let a;try{a=n.update(s),a=Buffer.concat([a,n.final()])}catch(c){throw c.message.includes("Unsupported state or unable to authenticate data")||c.message.includes("authentication")||c.message.includes("auth")||c.code==="ERR_CRYPTO_AUTH_FAILED"?new Error("Authentication failed: data has been tampered with"):new Error(`Decryption failed: ${c.message}`)}let o=a.toString("utf8");try{return JSON.parse(o)}catch{throw new Error("Authentication failed: decrypted data is not valid JSON")}}catch(e){throw e.message.includes("Authentication failed")?e:new Error(`Decryption failed: ${e.message}`)}}_encryptWALData(t){if(!this.options.walEnabled||!this.options.encrypt)return JSON.stringify(t);if(!this.walEncrypted||!this.walKey||!this.walSalt)throw new Error("WAL encryption not properly initialized - cannot write unencrypted data");try{let e=JSON.stringify(t),i=this.walKey;if(!i)throw new Error("WAL key not available during encryption");let r=u.randomBytes(16),s=Buffer.from(e,"utf8"),n=this._applyWALPaddingBuffer(s),a=u.createCipheriv("aes-256-gcm",i,r),o=a.update(n);o=Buffer.concat([o,a.final()]);let c=a.getAuthTag();return"WAL:"+r.toString("hex")+":"+c.toString("hex")+":"+o.toString("hex")}catch(e){throw new Error(`WAL encryption failed: ${e.message}`)}}_decryptWALData(t){if(!this.options.encrypt)try{return JSON.parse(t)}catch{throw new Error("Invalid unencrypted WAL data format")}try{if(!t.startsWith("WAL:"))try{return JSON.parse(t)}catch{throw new Error("Invalid WAL data format")}if(!this.walEncrypted||!this.walKey)throw new Error("Cannot decrypt WAL data: encryption not initialized");let i=t.substring(4).split(":");if(i.length!==3)throw new Error("Invalid encrypted WAL data format");let r=Buffer.from(i[0],"hex"),s=Buffer.from(i[1],"hex"),n=Buffer.from(i[2],"hex"),a=this.walKey;if(!a)throw new Error("WAL key not available during decryption");let o=u.createDecipheriv("aes-256-gcm",a,r);o.setAuthTag(s);let c=o.update(n);c=Buffer.concat([c,o.final()]);let f=this._removeWALPaddingBuffer(c).toString("utf8");return JSON.parse(f)}catch(e){throw new Error(`WAL decryption failed: ${e.message}`)}}_applyWALPaddingBuffer(t){let e=this.options.walPaddingSize,i=t.length,r;i>=e-4?r=Math.ceil((i+4)/e)*e:r=e;let s=r-i-4,n=u.randomBytes(s),a=Buffer.alloc(4);return a.writeUInt32BE(i,0),Buffer.concat([t,n,a])}_removeWALPaddingBuffer(t){if(t.length<4)throw new Error("Invalid padded buffer: too short");let e=t.readUInt32BE(t.length-4);if(e<0||e>t.length-4)throw new Error(`Invalid original length: ${e}`);return t.slice(0,e)}async _compressData(t){if(!this.options.compression)return t;try{return typeof t=="string"?await y(Buffer.from(t,"utf8")):Buffer.isBuffer(t)?await y(t):t}catch(e){return console.warn("Compression failed, using uncompressed data:",e.message),t}}async _decompressData(t){if(!this.options.compression)return t;try{return Buffer.isBuffer(t)?(await D(t)).toString("utf8"):t}catch{return Buffer.isBuffer(t)?t.toString("utf8"):t}}async _writeWAL(t){if(!this.options.walEnabled||this.isClosed)return;await this.ensureInitialized();let e={sequence:++this.walSequence,timestamp:Date.now(),operation:t,checksum:this._calculateChecksum(t)};this.walBuffer.push(e),this.options.syncWrites&&await this._flushWAL(),this.walBuffer.length*1e3>this.options.maxWalSize&&setImmediate(()=>this._checkpoint())}async _flushWAL(){if(this.walBuffer.length===0||this.isClosed)return;let t=d.join(this.databaseDir,"wal",`wal-${Date.now()}.log`),i=this.walBuffer.map(r=>this._encryptWALData(r)).join(`
`)+`
`;try{await h.mkdir(d.dirname(t),{recursive:!0})}catch{}await h.writeFile(t,i,{flag:"a"}),this.walBuffer=[]}async _recoverFromWAL(){if(this.options.encrypt&&this.options.walEnabled&&(!this.walEncrypted||!this.walKey))throw new Error("WAL encryption not properly initialized for recovery");let t=d.join(this.databaseDir,"wal"),e=[],i=0;try{await h.access(t)}catch{return}let s=(await h.readdir(t)).filter(n=>n.endsWith(".log")).sort();for(let n of s){if(n===".salt")continue;let a=d.join(t,n);try{let c=(await h.readFile(a,"utf8")).trim().split(`
`).filter(Boolean);for(let l of c)try{let f=this._decryptWALData(l);await this._applyWALEntry(f),i++}catch(f){console.warn(`[WAL RECOVERY] Failed to process entry in ${n}: ${f.message}`),e.push({file:n,entry:l.slice(0,80)+(l.length>80?"...":""),error:f.message})}}catch(o){console.warn(`[WAL RECOVERY] Failed to process WAL file ${n}: ${o.message}`),e.push({file:n,entry:null,error:o.message})}}e.length>0?(console.warn(`[WAL RECOVERY] Completed with ${e.length} failures and ${i} successful entries.`),this.lastWALRecoveryFailures=e):(console.info(`[WAL RECOVERY] All WAL entries recovered successfully (${i} entries).`),this.lastWALRecoveryFailures=[])}getWALRecoverySummary(){return{failures:this.lastWALRecoveryFailures||[],successCount:typeof this.lastWALRecoveryFailures>"u"?null:this.lastWALRecoveryFailures.length||0}}async _applyWALEntry(t){let{operation:e}=t;if(this._calculateChecksum(e)!==t.checksum)throw new Error("WAL entry checksum mismatch");switch(e.type){case"write":await this._writeDataDirect(e.tableName,e.data);break;case"create_table":await this._createTableDirect(e.tableName,e.schema);break;case"delete_table":await this._deleteTableDirect(e.tableName);break}}_calculateChecksum(t){return u.createHash("sha256").update(JSON.stringify(t)).digest("hex")}async _checkpoint(){if(!(this.isCheckpointing||this.isClosed)){this.isCheckpointing=!0;try{await this._flushWAL();let t=d.join(this.databaseDir,"wal"),e=await h.readdir(t),i=Date.now()-24*60*60*1e3;for(let r of e){if(r===".salt")continue;let s=d.join(t,r);try{(await h.stat(s)).mtime.getTime()<i&&await h.unlink(s)}catch{}}}finally{this.isCheckpointing=!1}}}_startCheckpointScheduler(){this.isClosed||(this.checkpointTimer=setInterval(()=>{this.isClosed||this._checkpoint().catch(console.error)},this.options.checkpointInterval))}_validateSchema(t,e){let i=this.schemas.get(t);return i?this._validateDataAgainstSchema(e,i):!0}_validateDataAgainstSchema(t,e){if(e.type=="array"&&Array.isArray(t)&&(e.type="object"),e.type&&typeof t!==e.type)throw new Error(`Type mismatch: expected ${e.type}, got ${typeof t}: ${JSON.stringify(t)}`);if(e.properties)for(let[i,r]of Object.entries(e.properties)){if(e.required&&e.required.includes(i)&&!(i in t))throw new Error(`Missing required property: ${i}`);i in t&&this._validateDataAgainstSchema(t[i],r)}return!0}async createTable(t,e=null){if(this.tableExists(t))throw new Error(`Table ${t} already exists`);let i={name:t,schema:e,rows:[],created:Date.now(),version:1};e&&this.schemas.set(t,e),await this._writeWAL({type:"create_table",tableName:t,schema:e}),await this._createTableDirect(t,i),this.eventEmitter.emit("createTable",t,i),e&&e.properties&&e.properties.id&&await this.createIndex(t,"id_idx",["id"])}async _createTableDirect(t,e){let i=d.join(this.databaseDir,`${t}.db`),r=this._encryptData(e);this.options.compression&&(r=await this._compressData(r)),await h.writeFile(i,r)}async deleteTable(t){if(!this.tableExists(t))throw new Error(`Table ${t} does not exist`);await this._writeWAL({type:"delete_table",tableName:t}),await this._deleteTableDirect(t),this.schemas.delete(t);for(let[e,i]of this.indexes)i.tableName===t&&this.indexes.delete(e);this.eventEmitter.emit("deleteTable",t)}async _deleteTableDirect(t){let e=d.join(this.databaseDir,`${t}.db`);try{await h.unlink(e)}catch(i){if(i.code!=="ENOENT")throw i}}async createIndex(t,e,i,r={}){let s=r.type||"btree",n=r.unique||!1,a=await this.readData(t,{}),o=new Map;for(let c of a){let l=this._buildIndexKey(c,i);if(n&&o.has(l))throw new Error(`Duplicate key violation for unique index: ${l}`);o.has(l)||o.set(l,[]),o.get(l).push(c.id||c)}this.indexes.set(e,{tableName:t,columns:i,type:s,unique:n,data:o}),await this._saveIndex(e),this.eventEmitter.emit("createIndex",t,e)}async dropIndex(t){if(!this.indexes.has(t))throw new Error(`Index ${t} does not exist`);this.indexes.delete(t);let e=d.join(this.databaseDir,"indexes",`${t}.idx`);try{await h.unlink(e)}catch(i){if(i.code!=="ENOENT")throw i}}_buildIndexKey(t,e){return e.map(i=>t[i]).join("::")}async _saveIndex(t){let e=this.indexes.get(t);if(!e)return;let i=d.join(this.databaseDir,"indexes",`${t}.idx`),r={...e,data:Array.from(e.data.entries())},s=this._encryptData(r);this.options.compression&&(s=await this._compressData(s)),await h.writeFile(i,s)}async startTransaction(t="READ_COMMITTED"){let e=u.randomBytes(16).toString("hex");return this.transactions.set(e,{id:e,operations:[],isolationLevel:t,startTime:Date.now(),locks:new Set,snapshot:new Map}),e}async commitTransaction(t){let e=this.transactions.get(t);if(!e)throw new Error(`Transaction ${t} not found`);try{for(let i of e.operations)await this._applyOperation(i);for(let i of e.locks)this._releaseLock(i,t);this.transactions.delete(t),this.eventEmitter.emit("commitTransaction",t)}catch(i){throw await this.rollbackTransaction(t),i}}async rollbackTransaction(t){let e=this.transactions.get(t);if(e){for(let i of e.locks)this._releaseLock(i,t);this.transactions.delete(t),this.eventEmitter.emit("rollbackTransaction",t)}}async addData(t,e,i=null){if(await this.ensureInitialized(),!i){i=await this.startTransaction();try{let s=await this.addData(t,e,i);return await this.commitTransaction(i),s}catch(s){throw await this.rollbackTransaction(i),s}}this._validateSchema(t,e),e.id||(e.id=u.randomBytes(16).toString("hex"));let r=this.transactions.get(i);return await this._acquireLock(t,i),r.operations.push({type:"add",tableName:t,data:{...e}}),await this._updateIndexesForAdd(t,e),this.eventEmitter.emit("add",t,e),e}async updateData(t,e,i,r=null){if(await this.ensureInitialized(),!r){r=await this.startTransaction();try{let o=await this.updateData(t,e,i,r);return await this.commitTransaction(r),o}catch(o){throw await this.rollbackTransaction(r),o}}this.schemas.has(t)&&this._validateSchema(t,i);let s=this.transactions.get(r);await this._acquireLock(t,r);let a=(await this.readData(t,{})).filter(o=>Object.entries(e).every(([c,l])=>l instanceof RegExp?l.test(o[c]):o[c]===l));for(let o of a){let c={...o,...i};o.id&&(c.id=o.id),s.operations.push({type:"update",tableName:t,oldData:{...o},newData:c,id:o.id}),await this._updateIndexesForUpdate(t,o,c)}return this.eventEmitter.emit("update",t,a,i),a.length}async deleteData(t,e,i=null){if(await this.ensureInitialized(),!i){i=await this.startTransaction();try{let a=await this.deleteData(t,e,i);return await this.commitTransaction(i),a}catch(a){throw await this.rollbackTransaction(i),a}}let r=this.transactions.get(i);await this._acquireLock(t,i);let n=(await this.readData(t,{})).filter(a=>Object.entries(e).every(([o,c])=>c instanceof RegExp?c.test(a[o]):a[o]===c));for(let a of n)r.operations.push({type:"delete",tableName:t,data:{...a},id:a.id}),await this._updateIndexesForDelete(t,a);return this.eventEmitter.emit("delete",t,n),n.length}async _updateIndexesForAdd(t,e){for(let[i,r]of this.indexes)if(r.tableName===t){let s=this._buildIndexKey(e,r.columns);if(r.unique&&r.data.has(s))throw new Error(`Unique constraint violation for index ${i}`);r.data.has(s)||r.data.set(s,[]),r.data.get(s).push(e.id)}}async _updateIndexesForUpdate(t,e,i){for(let[r,s]of this.indexes)if(s.tableName===t){let n=this._buildIndexKey(e,s.columns),a=this._buildIndexKey(i,s.columns);if(n!==a){if(s.unique&&s.data.has(a)&&!s.data.get(a).includes(e.id))throw new Error(`Unique constraint violation for index ${r}`);if(s.data.has(n)){let o=s.data.get(n),c=o.indexOf(e.id);c!==-1&&(o.splice(c,1),o.length===0&&s.data.delete(n))}s.data.has(a)||s.data.set(a,[]),s.data.get(a).push(i.id)}}}async _updateIndexesForDelete(t,e){for(let[i,r]of this.indexes)if(r.tableName===t){let s=this._buildIndexKey(e,r.columns);if(r.data.has(s)){let n=r.data.get(s),a=n.indexOf(e.id);a!==-1&&(n.splice(a,1),n.length===0&&r.data.delete(s))}}}async queryData(t,e={}){let{filter:i,sort:r,limit:s,offset:n,join:a}=e,o=await this._getDataWithIndex(t,i);if(o||(o=await this.readData(t,{})),i&&(o=this._applyFilter(o,i)),a&&(o=await this._applyJoin(o,a)),r&&(o=this._applySort(o,r)),s||n){let c=n||0,l=s?c+s:void 0;o=o.slice(c,l)}return o}tableExists(t){let e=d.join(this.databaseDir,`${t}.db`);return x.existsSync(e)}async _getDataWithIndex(t,e){if(!e||!e.conditions)return null;for(let[i,r]of this.indexes)if(r.tableName===t){let s=e.conditions.find(n=>r.columns.includes(n.column)&&n.operator==="==");if(s){let n=s.value,a=r.data.get(n)||[];return(await this.readData(t,{})).filter(c=>a.includes(c.id))}}return null}_applyFilter(t,e){let{operator:i,conditions:r}=e;return t.filter(s=>i==="and"?r.every(n=>this._evaluateCondition(s,n)):i==="or"?r.some(n=>this._evaluateCondition(s,n)):!0)}_evaluateCondition(t,e){let{column:i,operator:r,value:s}=e,n=t[i];switch(r){case"==":return n===s;case"!=":return n!==s;case">":return n>s;case">=":return n>=s;case"<":return n<s;case"<=":return n<=s;case"in":return Array.isArray(s)&&s.includes(n);case"like":return new RegExp(s,"i").test(n);case"contains":return new RegExp(s).test(n);default:return!1}}_applySort(t,e){let{column:i,direction:r="asc"}=e;return[...t].sort((s,n)=>{let a=s[i],o=n[i];return a<o?r==="asc"?-1:1:a>o?r==="asc"?1:-1:0})}async readData(t,e={}){let i=d.join(this.databaseDir,`${t}.db`);try{let r=await h.readFile(i);return this.options.compression&&(r=await this._decompressData(r)),(this._decryptData(r).rows||[]).filter(a=>Object.keys(e).length?Object.entries(e).every(([o,c])=>c instanceof RegExp?c.test(a[o]):a[o]===c):!0)}catch(r){throw r.code==="ENOENT"?new Error(`Table ${t} does not exist`):r}}async _writeDataDirect(t,e){let i=d.join(this.databaseDir,`${t}.db`),r={name:t,rows:e,lastModified:Date.now()},s=this._encryptData(r);this.options.compression&&(s=await this._compressData(s)),await h.writeFile(i,s)}async _acquireLock(t,e,i=null){let r=i||this.options.lockTimeout,s=Date.now();return new Promise((n,a)=>{(()=>{let c=this.locks.get(t);if(!c||c===e){this.locks.set(t,e);let l=this.transactions.get(e);l&&l.locks.add(t),n();return}if(Date.now()-s>=r){a(new Error(`Lock timeout for table ${t}`));return}this.lockQueue.has(t)||this.lockQueue.set(t,[]),this.lockQueue.get(t).push({transactionId:e,resolve:n,reject:a,startTime:s,timeout:r})})()})}_releaseLock(t,e){if(this.locks.get(t)===e){this.locks.delete(t);let r=this.lockQueue.get(t);if(r&&r.length>0){let s=r.shift();if(Date.now()-s.startTime<s.timeout){this.locks.set(t,s.transactionId);let a=this.transactions.get(s.transactionId);a&&a.locks.add(t),s.resolve()}else s.reject(new Error(`Lock timeout for table ${t}`));r.length===0&&this.lockQueue.delete(t)}}}async _applyOperation(t){switch(t.type){case"add":await this._applyAddOperation(t);break;case"update":await this._applyUpdateOperation(t);break;case"delete":await this._applyDeleteOperation(t);break;default:throw new Error(`Unknown operation type: ${t.type}`)}t.data&&Buffer.isBuffer(t.data)&&t.data.fill(0)}async _applyAddOperation(t){let{tableName:e,data:i}=t,r=await this.readData(e,{});if(r.some(s=>s.id===i.id))throw new Error(`Duplicate ID: ${i.id}`);r.push(i),await this._writeWAL({type:"write",tableName:e,data:r}),await this._writeDataDirect(e,r)}async _applyUpdateOperation(t){let{tableName:e,oldData:i,newData:r,id:s}=t,n=await this.readData(e,{}),a=n.findIndex(o=>o.id===s);if(a===-1)throw new Error(`Record with ID ${s} not found`);n[a]=r,await this._writeWAL({type:"write",tableName:e,data:n}),await this._writeDataDirect(e,n)}async _applyDeleteOperation(t){let{tableName:e,data:i,id:r}=t,s=await this.readData(e,{}),n=s.findIndex(a=>a.id===r);if(n===-1)throw new Error(`Record with ID ${r} not found`);s.splice(n,1),await this._writeWAL({type:"write",tableName:e,data:s}),await this._writeDataDirect(e,s)}async getStats(){return{tables:await this._getTableCount(),indexes:this.indexes.size,activeTransactions:this.transactions.size,walSequence:this.walSequence,memoryUsage:process.memoryUsage(),uptime:process.uptime(),locks:this.locks.size,lockQueue:Array.from(this.lockQueue.values()).reduce((t,e)=>t+e.length,0)}}async _getTableCount(){try{return(await h.readdir(this.databaseDir)).filter(e=>e.endsWith(".db")).length}catch{return 0}}async close(){this.isClosed||(this.isClosed=!0,this.checkpointTimer&&(clearInterval(this.checkpointTimer),this.checkpointTimer=null),await this._flushWAL(),await this._checkpoint(),this.lockQueue.clear(),this.locks.clear(),this.transactions.clear(),this.encryptionKey&&Buffer.isBuffer(this.encryptionKey)&&this.encryptionKey.fill(0),this.walKey&&Buffer.isBuffer(this.walKey)&&this.walKey.fill(0),this.walSalt&&Buffer.isBuffer(this.walSalt)&&this.walSalt.fill(0),this.encryptionKey=null,this.walKey=null,this.walSalt=null,this.eventEmitter.removeAllListeners())}on(t,e){this.eventEmitter.on(t,e)}removeListener(t,e){this.eventEmitter.removeListener(t,e)}};function E(){return u.randomBytes(32)}function k(p,t=null,e={}){return new w(p,t||E(),{encrypt:!0,compression:!0,walEnabled:!0,syncWrites:!0,...e})}module.exports={SlimCryptDB:w,generateEncryptionKey:E,createSecureDatabase:k};
